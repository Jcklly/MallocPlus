Test E:
	The purpose of this test case is to test out mallocing and freeing only large sizes. For this, I chose to malloc 62 64-byte chunks of the array, and then free them. Like the other test cases, this gets run one hundred times and the average time is given out. The reason I wanted to test this is to see the difference in speed between allocating small bytes and allocating large bytes. The difference was more or less then what I thought it would be, due to the face that we optimized efficiency over speed. There were parts in the malloc, fere, and coalescing implementation that could have been done in O(1) time, but are instead O(n) due to the effort to keep the metadata as small as possible. So what we were expecting was a large increase in time from the previous test cases, mainly the test A, and that is exactly what the outcome is.

Test F:
	This test case contains a number of different test within it. Starting from the top, we first malloc 1 byte, then 2, then 3, 4, 5, 6, all the way to 89 bytes. The result of this is simply mallocing the sum of the series, which is 3916 bytes in total. Then we free everything. This test is an execellent way to see how our malloc deals with memory allocation of different and increasing sizes. 
	The next test is similar to the first test, but now we are starting at 87 bytes and working our way down to 1. After everything is malloc'd we free everything. This is an excellent way to see how our malloc deals with a large allocation, then subsequent smaller allocations.
	In the next case, we are mallocing the max size of our array with the subtraction of our metadata for our inition foot and header, so 4096 - 2 - 2 which is 4092. We allocate this amount then immediately free it. This test handles the maximum allocation then free's it.
	The final case we are testing is similar to Test D, but with a larger random size. We set the random size to be between 1 and 250 bytes. It will randomly choose whether to malloc or to free, if it mallocs it will randomly choose the size between the 1 and 250 bytes. This test case HAS THE POSSIBILITY TO CREATE SATURATION OF DYNAMIC MEMORY ERRORS. If it randomly selects malloc, say 17 times, and randomly chooses 250 bytes for each of those 17 times, we have 250*17 which would be 4,250 bytes, exceeding out maximum memory of 4092 bytes. However, the possibility of creating the error is low, but this test shows not only it handleing larger random byte sizes, which is more realistic to how malloc is really used, but also shows how it properly handles errors without segmentation faults, exiting the program, or any unexpected behavior.

	All these test cases are run 1 after the other, and the time is recorded for how long it takes for them all to finish. It is run, like all the other test cases, 100 total times and the average is computed. If any error messages comes up, the proof that it is indead caused by Test F is simple to see from the "Line: %d" and "File: %s" that comes along with the error message. If it is indeed caused from Test F, then the line from the error message will correspond to a malloc within Test F.
